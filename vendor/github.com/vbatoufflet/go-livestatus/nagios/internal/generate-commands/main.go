package main

import (
	"bytes"
	"flag"
	"fmt"
	"net/http"
	"os"
	"regexp"
	"strconv"
	"strings"
	"text/template"

	wordwrap "github.com/mitchellh/go-wordwrap"
	"golang.org/x/net/html"
)

const (
	commandsIndex     = "https://old.nagios.org/developerinfo/externalcommands/"
	commandsURLPrefix = "commandinfo.php?command_id="
)

var (
	commandArgRegexp = regexp.MustCompile("<([a-z_]+)>")

	commandTypes = map[string]string{
		"author":                  "string",
		"check_attempts":          "int",
		"check_command":           "string",
		"check_interval":          "time.Duration",
		"check_time":              "time.Time",
		"check_timeperiod":        "string",
		"comment":                 "string",
		"comment_id":              "int",
		"contact_name":            "string",
		"contactgroup_name":       "string",
		"delete":                  "bool",
		"downtime_id":             "int",
		"duration":                "time.Duration",
		"end_time":                "time.Time",
		"event_handler_command":   "string",
		"file_name":               "string",
		"fixed":                   "bool",
		"host_name":               "string",
		"hostgroup_name":          "string",
		"notification_number":     "int",
		"notification_time":       "time.Time",
		"notification_timeperiod": "string",
		"notify":                  "bool",
		"options":                 "int",
		"persistent":              "bool",
		"plugin_output":           "string",
		"return_code":             "int",
		"service_description":     "string",
		"servicegroup_name":       "string",
		"start_time":              "time.Time",
		"status_code":             "int",
		"sticky":                  "bool",
		"timeperiod":              "string",
		"trigger_id":              "int",
		"value":                   "string",
		"varname":                 "string",
		"varvalue":                "string",
	}
)

func main() {
	var outputPath string

	flag.StringVar(&outputPath, "o", "", "output file path")
	flag.Parse()

	if outputPath == "" {
		die("missing -o mandatory option")
	}

	f, err := os.OpenFile(outputPath, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0644)
	if err != nil {
		die("failed to create output file: %s", err)
	}
	defer f.Close()

	template.Must(template.New("").Parse(`// Generated by go generate; DO NOT EDIT.

package nagios

import (
	"time"

	livestatus "github.com/vbatoufflet/go-livestatus"
)
{{- range .Commands }}

// {{ .FuncName }} creates a new "{{ .Name }}" Nagios command.
//
{{ .Description }}
{{- if .Args }}
func {{ .FuncName }}(
{{- range .Args }}
	{{ .Name }} {{ .Type }},
{{- end }}
) *livestatus.Command {
{{- else }}
func {{ .FuncName }}() *livestatus.Command {
{{- end }}
	return livestatus.NewCommand(
		"{{ .Name }}",
{{- range .Args }}
		stringifyArg("{{ .Name }}", "{{ .Type }}", {{ .Name }}),
{{- end }}
	)
}
{{- end }}
`,
	)).Execute(f, struct{ Commands []*command }{Commands: fetchCommands()})
}

func fetchCommands() []*command {
	var (
		id  int
		err error
	)

	commands := []*command{}
	commandsMap := map[string]struct{}{}

	resp, err := http.Get(commandsIndex)
	if err != nil {
		die("failed to fetch external commands: %s", err)
	}
	defer resp.Body.Close()

	t := html.NewTokenizer(resp.Body)
	for {
		tt := t.Next()
		switch tt {
		case html.ErrorToken:
			goto stop

		case html.StartTagToken:
			id = 0

			if tag, _ := t.TagName(); bytes.Equal(tag, []byte("a")) {
				for {
					key, val, moreAttr := t.TagAttr()
					if bytes.Equal(key, []byte("href")) && bytes.HasPrefix(val, []byte(commandsURLPrefix)) {
						id, err = strconv.Atoi(string(bytes.TrimPrefix(val, []byte(commandsURLPrefix))))
						if err != nil {
							die("failed to parse integer: %s", err)
						}
					} else if !moreAttr {
						break
					}
				}
			}

		case html.EndTagToken:
			id = 0

		case html.TextToken:
			if id > 0 {
				name := string(t.Text())

				if _, ok := commandsMap[name]; ok {
					fmt.Fprintf(os.Stderr, "Warning: skipping already defined %q command\n", name)
					continue
				}

				commands = append(commands, &command{
					ID:       id,
					Name:     name,
					FuncName: normalizeFuncName(name),
				})

				commandsMap[name] = struct{}{}
			}
		}
	}
stop:

	for _, cmd := range commands {
		var (
			formatFound bool
			descFound   bool
		)

		resp, err := http.Get(fmt.Sprintf("%s%s%d", commandsIndex, commandsURLPrefix, cmd.ID))
		if err != nil {
			die("failed to fetch external commands: %s", err)
		}
		defer resp.Body.Close()

		t := html.NewTokenizer(resp.Body)
		for {
			tt := t.Next()
			switch tt {
			case html.ErrorToken:
				goto next

			case html.TextToken:
				text := strings.TrimSpace(string(t.Text()))

				if len(text) == 0 {
					continue
				} else if text == "Command Format:" {
					formatFound = true
				} else if text == "Description:" {
					descFound = true
				} else if formatFound {
					for _, m := range commandArgRegexp.FindAllStringSubmatch(text, -1) {
						// FIXME: there are typos and duplicates for both "CHANGE_HOST_CHECK_TIMEPERIOD" and
						// "SCHEDULE_SVC_DOWNTIME", see:
						//  * https://old.nagios.org/developerinfo/externalcommands/commandinfo.php?command_id=119
						//  * https://old.nagios.org/developerinfo/externalcommands/commandinfo.php?command_id=133
						//  * https://old.nagios.org/developerinfo/externalcommands/commandinfo.php?command_id=138
						if m[1] == "check_timeperod" {
							m[1] = "check_timeperiod"
						} else if m[1] == "service_desription" {
							m[1] = "service_description"
						}

						typ := "interface{}"
						if v, ok := commandTypes[m[1]]; ok {
							typ = v
						}

						cmd.Args = append(cmd.Args, commandArg{
							Name: m[1],
							Type: typ,
						})
					}
					formatFound = false
				} else if descFound {
					text = strings.Replace(text, "  ", "\n\n", -1)

					lines := []string{}
					for _, line := range strings.Split(wordwrap.WrapString(text, 116), "\n") {
						if line == "" {
							line = "//"
						} else {
							line = "// " + line
						}

						lines = append(lines, line)
					}

					cmd.Description = strings.Join(lines, "\n")
					descFound = false
				}
			}
		}
	next:
	}

	return commands
}

func die(format string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, "Error: "+format+"\n", args...)
	os.Exit(1)
}

func normalizeFuncName(input string) string {
	parts := []string{}
	for _, part := range strings.Split(input, "_") {
		parts = append(parts, string(part[0])+strings.ToLower(part[1:]))
	}
	return strings.Join(parts, "")
}

type command struct {
	ID          int
	Name        string
	FuncName    string
	Description string
	Args        []commandArg
}

type commandArg struct {
	Name string
	Type string
}
